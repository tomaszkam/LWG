<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4519" status="SG1">
<title>No formal rule associates the total order of a mutex object with the rule for modification order</title>
<section><sref ref="[thread.mutex.requirements.mutex.general]"/></section>
<submitter>jim x</submitter>
<date>05 Feb 2026</date>
<priority>4</priority>

<discussion>
<p>
<sref ref="[thread.mutex.requirements.mutex.general]"/> p4 says (emphasis mine):
</p>
<blockquote>
<p>
For purposes of determining the existence of a data race, these behave as <b>atomic operations</b> 
(<sref ref="[intro.multithread]"/>). The lock and unlock operations on a single 
mutex appears to occur in <b>a single total order</b>.
</p>
</blockquote>
<p>
The second note in <sref ref="[thread.mutex.requirements.mutex.general]"/> p4
</p>
<blockquote><p>
[<i>Note 2</i>: This can be viewed as the modification order of the mutex. &mdash; <i>end note</i>]
</p></blockquote>
<p>
wants to inform the reader to interpret the single total order as a modification order. The review in 
LWG <iref ref="4475"/> says:
</p>
<blockquote><p>
For atomic objects, the modification order is already a single total order, `seq_cst` or not. This isn't a useful change.
</p></blockquote>
<p>
This implies that we want the single total order of a mutex object to be considered as the modification 
order of an atomic object for defining the order of the single total order by existing rules (especially, 
<sref ref="[intro.races]"/> p11-p14).
<p/>
However, the wording in <sref ref="[thread.mutex.requirements.mutex.general]"/> p1 (emphasis mine)
</p>
<blockquote><p>
In this description, `m` denotes <b>an object of a mutex type</b>.
</p></blockquote>
<p>
strongly implies that there is a difference between atomic objects and mutex objects. 
Except for the note, there is no formal wording to state that `lock()` and `unlock()` operations are 
modifications to the mutex object as if they were modifications to an atomic object for the purpose 
of determining the total order, that is, the rules defined in <sref ref="[intro.races]"/> that 
applies to an atomic object can also apply to an mutex object.
<p/>
For example:
</p>
<blockquote><pre>
#include &lt;mutex&gt;

std::mutex m;

int main(){
  m.lock(); // #1
  m.unlock(); // #2
}
</pre></blockquote>
<p>
The current formal wording only says `m` has a single total order. There is no formal wording 
that would associate the order of these operations in the total order of `m` with happens-before. 
We do want write-write coherence to apply to the total order of a mutex object. However, 
<sref ref="[intro.races]"/> p11 (emphasis mine),
</p>
<blockquote><p>
If an operation <tt><i>A</i></tt> that modifies <b>an atomic object <tt><i>M</i></tt></b> happens before 
an operation <tt><i>B</i></tt> that modifies <tt><i>M</i></tt>, then <tt><i>A</i></tt> is earlier 
than <tt><i>B</i></tt> in the modification order of <tt><i>M</i></tt>.
</p></blockquote>
<p>
only applies to <b>an atomic object</b>, as shown in the emphasized text. The definition of total order 
only says the order can be either <tt>#1 &lt; #2</tt> or <tt>#2 &lt; #1</tt>, either one of which is 
valid. Presumably, the intended meaning should be that the total order of the mutex object `m` in this 
program is <tt>#1 &lt; #2</tt> according to happens-before and <sref ref="[intro.races]"/> p11. 
</p>

<note>2026-02-27; Reflector poll.</note>
<p>
Set priority to 4 after reflector poll.
</p>
<p>
Opposition to the current proposed resolution was expressed,
as neither improving correctness nor clarity.
</p>

</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5032"/>.
</p>

<ol>
<li><p>Modify <sref ref="[thread.mutex.requirements.mutex.general]"/> as indicated:</p>

<blockquote>
<p>
-4- The implementation provides lock and unlock operations, as described below. For purposes of determining
the existence of a data race, these behave as atomic operations (<sref ref="[intro.multithread]"/>). 
T<ins>herefore, t</ins>he lock and unlock operations on a single mutex 
appears to occur in a single total order <ins>as if they were modifications to a hypothetical atomic 
object corresponding to the mutex object</ins>.
<p/>
[<i>Note 2</i>: This can be viewed as the modification order <del>(<sref ref="[intro.multithread]"/>)</del> of the 
mutex. <ins>Specifically, the requirements in <sref ref="[intro.races]"/> that are imposed on the 
modification order of an atomic object are also imposed on the total order of the mutex.</ins> &mdash; 
<i>end note</i>]
</p>
</blockquote>
</li>

</ol>
</resolution>

</issue>
